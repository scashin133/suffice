<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Frameset//EN""http://www.w3.org/TR/REC-html40/frameset.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc on Tue Jan 21 17:22:11 CET 2003 -->
<TITLE>
Jeks: Interface  Syntax
</TITLE>
<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">
</HEAD>
<BODY BGCOLOR="white">

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_top"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<A HREF='http://www.eteks.com'><FONT SIZE='+1'>http://www.eteks.com</FONT></A></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../com/eteks/parser/Interpreter.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;NEXT CLASS</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Syntax.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY: &nbsp;INNER&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL: &nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
com.eteks.parser</FONT>
<BR>
Interface  Syntax</H2>
<DL>
<DT><B>All Known Implementing Classes:</B> <DD><A HREF="../../../com/eteks/parser/AbstractSyntax.html">AbstractSyntax</A></DD>
</DL>
<HR>
<DL>
<DT>public interface <B>Syntax</B></DL>

<P>
Syntax used by parsers. This interface specifies all the keys and
 various methods used by a parser to check the syntax of parsed strings.<br>
 <code>getConstantKey ()</code>, <code>getUnaryOperatorKey ()</code>,
 <code>getBinaryOperatorKey ()</code>, <code>getConditionPartKey ()</code>,
 <code>getCommonFunctionKey ()</code> methods are called by the parser to check
 if a string extracted from a parsed expression is a valid lexical element or
 not for the syntax.
 These methods returns one of the <code>Integer</code> constants matching keys
 described in this interface if the extracted string is respectively a constant,
 an unary opertor, a binary operator, a condition part or a common function of the syntax.
 Examples :
 <UL><LI>If the string "*" is the multiplication binary operator of the implemented syntax
 the <code>getBinaryOperatorKey ()</code> method returns <code>OPERATOR_MULTIPLY</code>.</LI>
     <LI>If the string "Math.sin" is the sine common function of the implemented syntax
 the <code>getCommonFunctionKey ()</code> method returns <code>FUNCTION_SIN</code>.</LI></UL>
 The <code>getBinaryOperatorPriority ()</code> method returns a positive number telling
 the priority of each binary operator keys supported by the syntax. All the binary operators
 with the same priority are left-to-right associative. All the unary operators and function
 calls have the highest priority and are right-to-left associative.
 The condition operator has the lowest priority.<br>
 The <code>getLiteral ()</code> method extracts the string of a literal from parsed strings
 and returns the value of the literal valid for the syntax.<br>
 The other <code>get... ()</code> following methods are called by the parser to get
 the other elements that describes a syntax :
 <UL><LI><code>getWhiteSpaceCharacters ()</code> : returns a string that contains all the allowed white space
         delimiters (tab, spaces,...).</LI>
     <LI><code>getOpeningBracket ()</code> : returns the char used as an opening bracket.</LI>
     <LI><code>getClosingBracket ()</code> : returns the char used as a closing bracket.</LI>
     <LI><code>getParameterSeparator ()</code> : returns the char used to separate parameters in a function call.</LI>
     <LI><code>getDelimiters ()</code> : returns all the chars of the syntax
         (operators and above characters) that may be used as delimiters between literals, constants and identifiers.</LI>
     <LI><code>getAssignmentOperator ()</code> : returns a string used as the assignment
         operator by the parsers <code>FunctionParser</code> and <code>ExpressionParser</code>.</LI>
     <LI><code>isCaseSensitive ()</code> : returns <code>true</code> if identifiers, operators and functions
         of the syntax are case sensitive.</LI>
     <LI><code>isShortSyntax ()</code> : returns <code>true</code> if the syntax supports short cuts in expressions
         (no need to put between brackets common functions parameters between brackets).</LI>
     <LI><code>isValidIdentifier ()</code> : returns <code>true</code> if the string parameter
         can be considered as a user function paramater or an expression parameter.</LI></UL>
 Finally, the <code>getFunction ()</code> method is called by the parser to check if an extracted string
 is a user function, that may be a previous parsed function or a Java written function implementing the <code>Function</code>
 interface. This enables to chain calls with other functions.<br>
 Note that these methods simply returns 0 or null if a string or an element isn't
 accepted by the syntax. You can use the <code>AbstractSyntax</code> class to help you implement
 this interface. The classes <code>PascalSyntax</code> or <code>JavaSyntax</code> classes
 can be used to parse PASCAL or Java expressions and functions.<br>
 The classes implementing the <code>Interpreter</code> interface implements how to compute
 all the litterals, operators or functions of the syntax.<br>
 You can add a new litteral, operator or function in your syntax if you respect
 the following steps :
 <UL><LI>Create a new key that matches the new syntactic element. This key may be of class
         <code>Integer</code> or any other type as long as its unique in its category
         (constant, unary operator, binary operator or common function).
         If you create an <code>Integer</code> key, use a number greater or equal to
         <code>USER_STARTING_KEY</code> to avoid any problem.</LI>
     <LI>Return this key for the matching extracted string in the <code>get...Key ()</code> method
         of <code>Syntax</code> that accepts it as an lexical element of the syntax.
         If your syntax is a subclass of <code>AbstractSyntax</code>, you may also use the
         <code>set...Key ()</code> method to add directly the new key and its matching string
         to the syntax.</LI>
     <LI>Implement the computation of the new syntactic element in the equivalent
         <code>get...Value ()</code> method of <code>Interpreter</code> for the new key.</LI></UL>
 For example, imagine you want to add a common function "INV" in the syntax that computes
 the inverse of a number (1 / x). One solution could be :
 <UL><LI>Add to one of your classes the constant key <code>FUNCTION_INVERSE</code> equal to
         <code>new Integer (USER_STARTING_KEY)</code>.</LI>
     <LI>Return the key <code>FUNCTION_INVERSE</code> in your implementation of the
         <code>getCommonFunctionKey ()</code> method if its string parameter is equal to "INV".
         If your syntax is a subclass of <code>AbstractSyntax</code>, you can also call
         <code>setCommonFunctionKey ("INV", FUNCTION_INVERSE)</code> on the instance
         of <code>Syntax</code>.</LI>
     <LI>Implement the computation of the key <code>FUNCTION_INVERSE</code> in the
         <code>getCommonFunctionValue ()</code> method of <code>Interpreter</code>.</LI></UL>
 You should notice that the key is only used by the parser and the interpreter to
 link the recognized element by the syntax at parsing time to its computation code
 at interpretation time. This allows to interpret the same parsed expression or function with
 different implementations of <code>Interpreter</code>.<br>
 For example, the <code>com.eteks.tools.calculator.JeksCalculator</code> class implements the
 <code>Syntax</code> and <code>Interpreter</code> interfaces in a way it uses uppercase strings for all its keys.<br>
 Caution : The operators or functions syntax doesn't specify the type of the operands or
 the parameters. The type is checked at runtime by the class that implements the
 <code>Interpreter</code> interface.<br>
 It's possible also to add a new function with any number of parameters to the syntax,
 if this function implements the <code>Function</code> interface and if it's returned by
 the <code>getFunction ()</code> method.
<P>
<DL>
<DT><B>Since: </B><DD>Jeks 1.0</DD>
<DT><B>Version: </B><DD>1.0</DD>
<DT><B>Author: </B><DD>Emmanuel Puybaret</DD>
<DT><B>See Also: </B><DD><A HREF="../../../com/eteks/parser/AbstractSyntax.html"><CODE>AbstractSyntax</CODE></A>, 
<A HREF="../../../com/eteks/parser/Interpreter.html"><CODE>Interpreter</CODE></A>, 
<A HREF="../../../com/eteks/parser/Function.html"><CODE>Function</CODE></A>, 
<CODE>com.eteks.tools.calculator.JeksCalculator</CODE></DL>
<HR>

<P>
<!-- ======== INNER CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Field Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#CONDITION_ELSE">CONDITION_ELSE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key returned by <code>getConditionPartKey ()</code> for the else part of a condition.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#CONDITION_IF">CONDITION_IF</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key returned by <code>getConditionPartKey ()</code> for the if part of a condition. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#CONDITION_THEN">CONDITION_THEN</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key returned by <code>getConditionPartKey ()</code> for the then part of a condition.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#CONSTANT_E">CONSTANT_E</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key returned by <code>getConstantKey ()</code> for the constant number E (exp (1)).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#CONSTANT_FALSE">CONSTANT_FALSE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key returned by <code>getConstantKey ()</code> for the constant false.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#CONSTANT_PI">CONSTANT_PI</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key returned by <code>getConstantKey ()</code> for the constant  PI.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#CONSTANT_TRUE">CONSTANT_TRUE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key returned by <code>getConstantKey ()</code> for the constant true.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#FUNCTION_ABS">FUNCTION_ABS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key returned by <code>getCommonFunctionKey ()</code> for the absolute value function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#FUNCTION_ACOS">FUNCTION_ACOS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key returned by <code>getCommonFunctionKey ()</code> for the arc cosine function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#FUNCTION_ASIN">FUNCTION_ASIN</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key returned by <code>getCommonFunctionKey ()</code> for the arc sine function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#FUNCTION_ATAN">FUNCTION_ATAN</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key returned by <code>getCommonFunctionKey ()</code> for the arc tangent function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#FUNCTION_CEIL">FUNCTION_CEIL</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key returned by <code>getCommonFunctionKey ()</code> for the ceil value function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#FUNCTION_COS">FUNCTION_COS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key returned by <code>getCommonFunctionKey ()</code> for the cosine function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#FUNCTION_COSH">FUNCTION_COSH</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key returned by <code>getCommonFunctionKey ()</code> for the hyperbolic sine function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#FUNCTION_EXP">FUNCTION_EXP</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key returned by <code>getCommonFunctionKey ()</code> for the exponential function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#FUNCTION_FLOOR">FUNCTION_FLOOR</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key returned by <code>getCommonFunctionKey ()</code> for the floor value function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#FUNCTION_INTEGER">FUNCTION_INTEGER</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key returned by <code>getCommonFunctionKey ()</code> for the integer part function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#FUNCTION_LN">FUNCTION_LN</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key returned by <code>getCommonFunctionKey ()</code> for the nepierian logarithm function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#FUNCTION_LOG">FUNCTION_LOG</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key returned by <code>getCommonFunctionKey ()</code> for the decimal logarithm function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#FUNCTION_NOT">FUNCTION_NOT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key returned by <code>getCommonFunctionKey ()</code> for the not function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#FUNCTION_OPPOSITE">FUNCTION_OPPOSITE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key returned by <code>getCommonFunctionKey ()</code> for the opposite function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#FUNCTION_ROUND">FUNCTION_ROUND</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key returned by <code>getCommonFunctionKey ()</code> for the round value function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#FUNCTION_SIN">FUNCTION_SIN</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key returned by <code>getCommonFunctionKey ()</code> for the sine function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#FUNCTION_SINH">FUNCTION_SINH</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key returned by <code>getCommonFunctionKey ()</code> for the hyperbolic sine function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#FUNCTION_SQR">FUNCTION_SQR</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key returned by <code>getCommonFunctionKey ()</code> for the square function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#FUNCTION_SQRT">FUNCTION_SQRT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key returned by <code>getCommonFunctionKey ()</code> for the square root function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#FUNCTION_TAN">FUNCTION_TAN</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key returned by <code>getCommonFunctionKey ()</code> for the tangent function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#FUNCTION_TANH">FUNCTION_TANH</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key returned by <code>getCommonFunctionKey ()</code> for the hyperbolic tangent function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#OPERATOR_ADD">OPERATOR_ADD</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key returned by <code>getBinaryOperatorKey ()</code> for the add operator.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#OPERATOR_BITWISE_AND">OPERATOR_BITWISE_AND</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key returned by <code>getBinaryOperatorKey ()</code> for the bitwise and operator.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#OPERATOR_BITWISE_NOT">OPERATOR_BITWISE_NOT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key returned by <code>getUnaryOperatorKey ()</code> for the bitwise not operator.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#OPERATOR_BITWISE_OR">OPERATOR_BITWISE_OR</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key returned by <code>getBinaryOperatorKey ()</code> for the bitwise or operator.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#OPERATOR_BITWISE_XOR">OPERATOR_BITWISE_XOR</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key returned by <code>getBinaryOperatorKey ()</code> for the bitwise xor operator.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#OPERATOR_DIFFERENT">OPERATOR_DIFFERENT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key returned by <code>getBinaryOperatorKey ()</code> for the different operator.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#OPERATOR_DIVIDE">OPERATOR_DIVIDE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key returned by <code>getBinaryOperatorKey ()</code> for the divide operator.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#OPERATOR_EQUAL">OPERATOR_EQUAL</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key returned by <code>getBinaryOperatorKey ()</code> for the equal operator.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#OPERATOR_GREATER">OPERATOR_GREATER</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key returned by <code>getBinaryOperatorKey ()</code> for the greater operator.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#OPERATOR_GREATER_OR_EQUAL">OPERATOR_GREATER_OR_EQUAL</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key returned by <code>getBinaryOperatorKey ()</code> for the greater or equal operator.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#OPERATOR_LESS">OPERATOR_LESS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key returned by <code>getBinaryOperatorKey ()</code> for the less operator.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#OPERATOR_LESS_OR_EQUAL">OPERATOR_LESS_OR_EQUAL</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key returned by <code>getBinaryOperatorKey ()</code> for the less or equal operator.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#OPERATOR_LOGICAL_AND">OPERATOR_LOGICAL_AND</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key returned by <code>getBinaryOperatorKey ()</code> for the logical and operator.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#OPERATOR_LOGICAL_NOT">OPERATOR_LOGICAL_NOT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key returned by <code>getUnaryOperatorKey ()</code> for the logical not operator.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#OPERATOR_LOGICAL_OR">OPERATOR_LOGICAL_OR</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key returned by <code>getBinaryOperatorKey ()</code> for the logical or operator.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#OPERATOR_LOGICAL_XOR">OPERATOR_LOGICAL_XOR</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key returned by <code>getBinaryOperatorKey ()</code> for the logical xor operator.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#OPERATOR_MODULO">OPERATOR_MODULO</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key returned by <code>getBinaryOperatorKey ()</code> for the modulo operator.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#OPERATOR_MULTIPLY">OPERATOR_MULTIPLY</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key returned by <code>getBinaryOperatorKey ()</code> for the multiply operator.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#OPERATOR_OPPOSITE">OPERATOR_OPPOSITE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key returned by <code>getUnaryOperatorKey ()</code> for the opposite operator.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#OPERATOR_POSITIVE">OPERATOR_POSITIVE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key returned by <code>getUnaryOperatorKey ()</code> for the positive operator.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#OPERATOR_POWER">OPERATOR_POWER</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key returned by <code>getBinaryOperatorKey ()</code> for the power operator.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#OPERATOR_REMAINDER">OPERATOR_REMAINDER</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key returned by <code>getBinaryOperatorKey ()</code> for the remainder operator.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#OPERATOR_SHIFT_LEFT">OPERATOR_SHIFT_LEFT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key returned by <code>getBinaryOperatorKey ()</code> for the shift left operator.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#OPERATOR_SHIFT_RIGHT">OPERATOR_SHIFT_RIGHT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key returned by <code>getBinaryOperatorKey ()</code> for the shift right operator.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#OPERATOR_SHIFT_RIGHT_0">OPERATOR_SHIFT_RIGHT_0</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key returned by <code>getBinaryOperatorKey ()</code> for the shift right operator (Java operator >>>).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#OPERATOR_SUBSTRACT">OPERATOR_SUBSTRACT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key returned by <code>getBinaryOperatorKey ()</code> for the substract operator.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#USER_STARTING_KEY">USER_STARTING_KEY</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key starting value for user keys.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->


<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#getAssignmentOperator()">getAssignmentOperator</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the string used as the operator of assignment by
 the parsers <code>FunctionParser</code> and <code>ExpressionParser</code>.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#getBinaryOperatorKey(java.lang.String)">getBinaryOperatorKey</A></B>(java.lang.String&nbsp;binaryOperator)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the key matching <code>binaryOperator</code> (one of <code>OPERATOR_ADD</code>,
 <code>OPERATOR_SUBSTRACT</code>, <code>OPERATOR_MULTIPLY</code>, <code>OPERATOR_DIVIDE</code>,... or
 an other user defined key). </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#getBinaryOperatorPriority(java.lang.Object)">getBinaryOperatorPriority</A></B>(java.lang.Object&nbsp;binaryOperatorKey)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the priority of the binary operator matching the key <code>binaryOperatorKey</code>. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;char</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#getClosingBracket()">getClosingBracket</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the char used as the closing bracket of the syntax. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#getCommonFunctionKey(java.lang.String)">getCommonFunctionKey</A></B>(java.lang.String&nbsp;commonFunction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the key matching <code>commonFunction</code> (one of <code>FUNCTION_LN</code>,
 <code>FUNCTION_LOG</code>, <code>FUNCTION_EXP</code>, <code>FUNCTION_SQR</code>,... or
 an other user defined key). </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#getConditionPartCount()">getConditionPartCount</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns 2 or 3 depending on whether the syntax using a condition with two or three parts (then else
 parts or if then else parts. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#getConditionPartKey(java.lang.String)">getConditionPartKey</A></B>(java.lang.String&nbsp;conditionPart)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the key matching <code>conditionPart</code> (one of <code>CONDITION_IF</code>,
 <code>CONDITION_THEN</code>, <code>CONDITION_ELSE</code>). </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#getConstantKey(java.lang.String)">getConstantKey</A></B>(java.lang.String&nbsp;constant)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the key matching <code>constant</code> (one of <code>CONSTANT_PI</code>,
 <code>CONSTANT_E</code>, <code>CONSTANT_FALSE</code>, <code>CONSTANT_TRUE</code> or
 an other user defined key). </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#getDelimiters()">getDelimiters</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns all the chars of the syntax that may be used as delimiters
 between literals, constants and other identifiers. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/eteks/parser/Function.html">Function</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#getFunction(java.lang.String)">getFunction</A></B>(java.lang.String&nbsp;functionName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a reference to the instance of <code>Function</code> whose name is <code>functionName</code>.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#getLiteral(java.lang.String, java.lang.StringBuffer)">getLiteral</A></B>(java.lang.String&nbsp;expression,
           java.lang.StringBuffer&nbsp;extractedLiteral)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the value of the literal parsed from the string <code>expression</code>
 or <code>null</code> if <code>expression</code> doesn't start with a literal. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;char</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#getOpeningBracket()">getOpeningBracket</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the char used as the opening bracket of the syntax. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;char</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#getParameterSeparator()">getParameterSeparator</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the char used to separate parameters in a function call. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#getUnaryOperatorKey(java.lang.String)">getUnaryOperatorKey</A></B>(java.lang.String&nbsp;unaryOperator)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the key matching <code>unaryOperator</code> (one of <code>OPERATOR_POSITIVE</code>,
 <code>OPERATOR_OPPOSITE</code>, <code>OPERATOR_LOGICAL_NOT</code>, <code>OPERATOR_BITWISE_NOT</code> or
 an other user defined key). </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#getWhiteSpaceCharacters()">getWhiteSpaceCharacters</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a string that contains all the delimiters allowed by the syntax as white spaces
 (tab, spaces,...).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#isCaseSensitive()">isCaseSensitive</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if identifiers, constants, operators and function of the syntax
 are case sensitive. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#isShortSyntax()">isShortSyntax</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if expressions parsed with this syntax supports short cuts.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/eteks/parser/Syntax.html#isValidIdentifier(java.lang.String)">isValidIdentifier</A></B>(java.lang.String&nbsp;identifier)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if the string <code>identifier</code> is a correctly written identifier
 to be used as a user function name, a user function paramater name or an expression parameter.
 </TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Field Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="CONSTANT_PI"><!-- --></A><H3>
CONSTANT_PI</H3>
<PRE>
public static final java.lang.Integer <B>CONSTANT_PI</B></PRE>
<DL>
<DD>Key returned by <code>getConstantKey ()</code> for the constant  PI.</DL>
<HR>

<A NAME="CONSTANT_E"><!-- --></A><H3>
CONSTANT_E</H3>
<PRE>
public static final java.lang.Integer <B>CONSTANT_E</B></PRE>
<DL>
<DD>Key returned by <code>getConstantKey ()</code> for the constant number E (exp (1)).</DL>
<HR>

<A NAME="CONSTANT_FALSE"><!-- --></A><H3>
CONSTANT_FALSE</H3>
<PRE>
public static final java.lang.Integer <B>CONSTANT_FALSE</B></PRE>
<DL>
<DD>Key returned by <code>getConstantKey ()</code> for the constant false.</DL>
<HR>

<A NAME="CONSTANT_TRUE"><!-- --></A><H3>
CONSTANT_TRUE</H3>
<PRE>
public static final java.lang.Integer <B>CONSTANT_TRUE</B></PRE>
<DL>
<DD>Key returned by <code>getConstantKey ()</code> for the constant true.</DL>
<HR>

<A NAME="OPERATOR_POSITIVE"><!-- --></A><H3>
OPERATOR_POSITIVE</H3>
<PRE>
public static final java.lang.Integer <B>OPERATOR_POSITIVE</B></PRE>
<DL>
<DD>Key returned by <code>getUnaryOperatorKey ()</code> for the positive operator.</DL>
<HR>

<A NAME="OPERATOR_OPPOSITE"><!-- --></A><H3>
OPERATOR_OPPOSITE</H3>
<PRE>
public static final java.lang.Integer <B>OPERATOR_OPPOSITE</B></PRE>
<DL>
<DD>Key returned by <code>getUnaryOperatorKey ()</code> for the opposite operator.</DL>
<HR>

<A NAME="OPERATOR_LOGICAL_NOT"><!-- --></A><H3>
OPERATOR_LOGICAL_NOT</H3>
<PRE>
public static final java.lang.Integer <B>OPERATOR_LOGICAL_NOT</B></PRE>
<DL>
<DD>Key returned by <code>getUnaryOperatorKey ()</code> for the logical not operator.</DL>
<HR>

<A NAME="OPERATOR_BITWISE_NOT"><!-- --></A><H3>
OPERATOR_BITWISE_NOT</H3>
<PRE>
public static final java.lang.Integer <B>OPERATOR_BITWISE_NOT</B></PRE>
<DL>
<DD>Key returned by <code>getUnaryOperatorKey ()</code> for the bitwise not operator.</DL>
<HR>

<A NAME="OPERATOR_ADD"><!-- --></A><H3>
OPERATOR_ADD</H3>
<PRE>
public static final java.lang.Integer <B>OPERATOR_ADD</B></PRE>
<DL>
<DD>Key returned by <code>getBinaryOperatorKey ()</code> for the add operator.</DL>
<HR>

<A NAME="OPERATOR_SUBSTRACT"><!-- --></A><H3>
OPERATOR_SUBSTRACT</H3>
<PRE>
public static final java.lang.Integer <B>OPERATOR_SUBSTRACT</B></PRE>
<DL>
<DD>Key returned by <code>getBinaryOperatorKey ()</code> for the substract operator.</DL>
<HR>

<A NAME="OPERATOR_MULTIPLY"><!-- --></A><H3>
OPERATOR_MULTIPLY</H3>
<PRE>
public static final java.lang.Integer <B>OPERATOR_MULTIPLY</B></PRE>
<DL>
<DD>Key returned by <code>getBinaryOperatorKey ()</code> for the multiply operator.</DL>
<HR>

<A NAME="OPERATOR_DIVIDE"><!-- --></A><H3>
OPERATOR_DIVIDE</H3>
<PRE>
public static final java.lang.Integer <B>OPERATOR_DIVIDE</B></PRE>
<DL>
<DD>Key returned by <code>getBinaryOperatorKey ()</code> for the divide operator.</DL>
<HR>

<A NAME="OPERATOR_POWER"><!-- --></A><H3>
OPERATOR_POWER</H3>
<PRE>
public static final java.lang.Integer <B>OPERATOR_POWER</B></PRE>
<DL>
<DD>Key returned by <code>getBinaryOperatorKey ()</code> for the power operator.</DL>
<HR>

<A NAME="OPERATOR_MODULO"><!-- --></A><H3>
OPERATOR_MODULO</H3>
<PRE>
public static final java.lang.Integer <B>OPERATOR_MODULO</B></PRE>
<DL>
<DD>Key returned by <code>getBinaryOperatorKey ()</code> for the modulo operator.</DL>
<HR>

<A NAME="OPERATOR_REMAINDER"><!-- --></A><H3>
OPERATOR_REMAINDER</H3>
<PRE>
public static final java.lang.Integer <B>OPERATOR_REMAINDER</B></PRE>
<DL>
<DD>Key returned by <code>getBinaryOperatorKey ()</code> for the remainder operator.</DL>
<HR>

<A NAME="OPERATOR_EQUAL"><!-- --></A><H3>
OPERATOR_EQUAL</H3>
<PRE>
public static final java.lang.Integer <B>OPERATOR_EQUAL</B></PRE>
<DL>
<DD>Key returned by <code>getBinaryOperatorKey ()</code> for the equal operator.</DL>
<HR>

<A NAME="OPERATOR_DIFFERENT"><!-- --></A><H3>
OPERATOR_DIFFERENT</H3>
<PRE>
public static final java.lang.Integer <B>OPERATOR_DIFFERENT</B></PRE>
<DL>
<DD>Key returned by <code>getBinaryOperatorKey ()</code> for the different operator.</DL>
<HR>

<A NAME="OPERATOR_GREATER_OR_EQUAL"><!-- --></A><H3>
OPERATOR_GREATER_OR_EQUAL</H3>
<PRE>
public static final java.lang.Integer <B>OPERATOR_GREATER_OR_EQUAL</B></PRE>
<DL>
<DD>Key returned by <code>getBinaryOperatorKey ()</code> for the greater or equal operator.</DL>
<HR>

<A NAME="OPERATOR_LESS_OR_EQUAL"><!-- --></A><H3>
OPERATOR_LESS_OR_EQUAL</H3>
<PRE>
public static final java.lang.Integer <B>OPERATOR_LESS_OR_EQUAL</B></PRE>
<DL>
<DD>Key returned by <code>getBinaryOperatorKey ()</code> for the less or equal operator.</DL>
<HR>

<A NAME="OPERATOR_GREATER"><!-- --></A><H3>
OPERATOR_GREATER</H3>
<PRE>
public static final java.lang.Integer <B>OPERATOR_GREATER</B></PRE>
<DL>
<DD>Key returned by <code>getBinaryOperatorKey ()</code> for the greater operator.</DL>
<HR>

<A NAME="OPERATOR_LESS"><!-- --></A><H3>
OPERATOR_LESS</H3>
<PRE>
public static final java.lang.Integer <B>OPERATOR_LESS</B></PRE>
<DL>
<DD>Key returned by <code>getBinaryOperatorKey ()</code> for the less operator.</DL>
<HR>

<A NAME="OPERATOR_LOGICAL_OR"><!-- --></A><H3>
OPERATOR_LOGICAL_OR</H3>
<PRE>
public static final java.lang.Integer <B>OPERATOR_LOGICAL_OR</B></PRE>
<DL>
<DD>Key returned by <code>getBinaryOperatorKey ()</code> for the logical or operator.</DL>
<HR>

<A NAME="OPERATOR_LOGICAL_AND"><!-- --></A><H3>
OPERATOR_LOGICAL_AND</H3>
<PRE>
public static final java.lang.Integer <B>OPERATOR_LOGICAL_AND</B></PRE>
<DL>
<DD>Key returned by <code>getBinaryOperatorKey ()</code> for the logical and operator.</DL>
<HR>

<A NAME="OPERATOR_LOGICAL_XOR"><!-- --></A><H3>
OPERATOR_LOGICAL_XOR</H3>
<PRE>
public static final java.lang.Integer <B>OPERATOR_LOGICAL_XOR</B></PRE>
<DL>
<DD>Key returned by <code>getBinaryOperatorKey ()</code> for the logical xor operator.</DL>
<HR>

<A NAME="OPERATOR_BITWISE_OR"><!-- --></A><H3>
OPERATOR_BITWISE_OR</H3>
<PRE>
public static final java.lang.Integer <B>OPERATOR_BITWISE_OR</B></PRE>
<DL>
<DD>Key returned by <code>getBinaryOperatorKey ()</code> for the bitwise or operator.</DL>
<HR>

<A NAME="OPERATOR_BITWISE_XOR"><!-- --></A><H3>
OPERATOR_BITWISE_XOR</H3>
<PRE>
public static final java.lang.Integer <B>OPERATOR_BITWISE_XOR</B></PRE>
<DL>
<DD>Key returned by <code>getBinaryOperatorKey ()</code> for the bitwise xor operator.</DL>
<HR>

<A NAME="OPERATOR_BITWISE_AND"><!-- --></A><H3>
OPERATOR_BITWISE_AND</H3>
<PRE>
public static final java.lang.Integer <B>OPERATOR_BITWISE_AND</B></PRE>
<DL>
<DD>Key returned by <code>getBinaryOperatorKey ()</code> for the bitwise and operator.</DL>
<HR>

<A NAME="OPERATOR_SHIFT_LEFT"><!-- --></A><H3>
OPERATOR_SHIFT_LEFT</H3>
<PRE>
public static final java.lang.Integer <B>OPERATOR_SHIFT_LEFT</B></PRE>
<DL>
<DD>Key returned by <code>getBinaryOperatorKey ()</code> for the shift left operator.</DL>
<HR>

<A NAME="OPERATOR_SHIFT_RIGHT"><!-- --></A><H3>
OPERATOR_SHIFT_RIGHT</H3>
<PRE>
public static final java.lang.Integer <B>OPERATOR_SHIFT_RIGHT</B></PRE>
<DL>
<DD>Key returned by <code>getBinaryOperatorKey ()</code> for the shift right operator.</DL>
<HR>

<A NAME="OPERATOR_SHIFT_RIGHT_0"><!-- --></A><H3>
OPERATOR_SHIFT_RIGHT_0</H3>
<PRE>
public static final java.lang.Integer <B>OPERATOR_SHIFT_RIGHT_0</B></PRE>
<DL>
<DD>Key returned by <code>getBinaryOperatorKey ()</code> for the shift right operator (Java operator >>>).</DL>
<HR>

<A NAME="CONDITION_IF"><!-- --></A><H3>
CONDITION_IF</H3>
<PRE>
public static final java.lang.Integer <B>CONDITION_IF</B></PRE>
<DL>
<DD>Key returned by <code>getConditionPartKey ()</code> for the if part of a condition. If the
 syntax uses a condition with only two parts for the then and
 else parts of the condition (like the operator ? : in Java), the <code>getConditionPartCount ()</code>
 method returns 2.</DL>
<HR>

<A NAME="CONDITION_THEN"><!-- --></A><H3>
CONDITION_THEN</H3>
<PRE>
public static final java.lang.Integer <B>CONDITION_THEN</B></PRE>
<DL>
<DD>Key returned by <code>getConditionPartKey ()</code> for the then part of a condition.</DL>
<HR>

<A NAME="CONDITION_ELSE"><!-- --></A><H3>
CONDITION_ELSE</H3>
<PRE>
public static final java.lang.Integer <B>CONDITION_ELSE</B></PRE>
<DL>
<DD>Key returned by <code>getConditionPartKey ()</code> for the else part of a condition.</DL>
<HR>

<A NAME="FUNCTION_LN"><!-- --></A><H3>
FUNCTION_LN</H3>
<PRE>
public static final java.lang.Integer <B>FUNCTION_LN</B></PRE>
<DL>
<DD>Key returned by <code>getCommonFunctionKey ()</code> for the nepierian logarithm function.</DL>
<HR>

<A NAME="FUNCTION_LOG"><!-- --></A><H3>
FUNCTION_LOG</H3>
<PRE>
public static final java.lang.Integer <B>FUNCTION_LOG</B></PRE>
<DL>
<DD>Key returned by <code>getCommonFunctionKey ()</code> for the decimal logarithm function.</DL>
<HR>

<A NAME="FUNCTION_EXP"><!-- --></A><H3>
FUNCTION_EXP</H3>
<PRE>
public static final java.lang.Integer <B>FUNCTION_EXP</B></PRE>
<DL>
<DD>Key returned by <code>getCommonFunctionKey ()</code> for the exponential function.</DL>
<HR>

<A NAME="FUNCTION_SQR"><!-- --></A><H3>
FUNCTION_SQR</H3>
<PRE>
public static final java.lang.Integer <B>FUNCTION_SQR</B></PRE>
<DL>
<DD>Key returned by <code>getCommonFunctionKey ()</code> for the square function.</DL>
<HR>

<A NAME="FUNCTION_SQRT"><!-- --></A><H3>
FUNCTION_SQRT</H3>
<PRE>
public static final java.lang.Integer <B>FUNCTION_SQRT</B></PRE>
<DL>
<DD>Key returned by <code>getCommonFunctionKey ()</code> for the square root function.</DL>
<HR>

<A NAME="FUNCTION_COS"><!-- --></A><H3>
FUNCTION_COS</H3>
<PRE>
public static final java.lang.Integer <B>FUNCTION_COS</B></PRE>
<DL>
<DD>Key returned by <code>getCommonFunctionKey ()</code> for the cosine function.</DL>
<HR>

<A NAME="FUNCTION_SIN"><!-- --></A><H3>
FUNCTION_SIN</H3>
<PRE>
public static final java.lang.Integer <B>FUNCTION_SIN</B></PRE>
<DL>
<DD>Key returned by <code>getCommonFunctionKey ()</code> for the sine function.</DL>
<HR>

<A NAME="FUNCTION_TAN"><!-- --></A><H3>
FUNCTION_TAN</H3>
<PRE>
public static final java.lang.Integer <B>FUNCTION_TAN</B></PRE>
<DL>
<DD>Key returned by <code>getCommonFunctionKey ()</code> for the tangent function.</DL>
<HR>

<A NAME="FUNCTION_ACOS"><!-- --></A><H3>
FUNCTION_ACOS</H3>
<PRE>
public static final java.lang.Integer <B>FUNCTION_ACOS</B></PRE>
<DL>
<DD>Key returned by <code>getCommonFunctionKey ()</code> for the arc cosine function.</DL>
<HR>

<A NAME="FUNCTION_ASIN"><!-- --></A><H3>
FUNCTION_ASIN</H3>
<PRE>
public static final java.lang.Integer <B>FUNCTION_ASIN</B></PRE>
<DL>
<DD>Key returned by <code>getCommonFunctionKey ()</code> for the arc sine function.</DL>
<HR>

<A NAME="FUNCTION_ATAN"><!-- --></A><H3>
FUNCTION_ATAN</H3>
<PRE>
public static final java.lang.Integer <B>FUNCTION_ATAN</B></PRE>
<DL>
<DD>Key returned by <code>getCommonFunctionKey ()</code> for the arc tangent function.</DL>
<HR>

<A NAME="FUNCTION_COSH"><!-- --></A><H3>
FUNCTION_COSH</H3>
<PRE>
public static final java.lang.Integer <B>FUNCTION_COSH</B></PRE>
<DL>
<DD>Key returned by <code>getCommonFunctionKey ()</code> for the hyperbolic sine function.</DL>
<HR>

<A NAME="FUNCTION_SINH"><!-- --></A><H3>
FUNCTION_SINH</H3>
<PRE>
public static final java.lang.Integer <B>FUNCTION_SINH</B></PRE>
<DL>
<DD>Key returned by <code>getCommonFunctionKey ()</code> for the hyperbolic sine function.</DL>
<HR>

<A NAME="FUNCTION_TANH"><!-- --></A><H3>
FUNCTION_TANH</H3>
<PRE>
public static final java.lang.Integer <B>FUNCTION_TANH</B></PRE>
<DL>
<DD>Key returned by <code>getCommonFunctionKey ()</code> for the hyperbolic tangent function.</DL>
<HR>

<A NAME="FUNCTION_INTEGER"><!-- --></A><H3>
FUNCTION_INTEGER</H3>
<PRE>
public static final java.lang.Integer <B>FUNCTION_INTEGER</B></PRE>
<DL>
<DD>Key returned by <code>getCommonFunctionKey ()</code> for the integer part function.</DL>
<HR>

<A NAME="FUNCTION_FLOOR"><!-- --></A><H3>
FUNCTION_FLOOR</H3>
<PRE>
public static final java.lang.Integer <B>FUNCTION_FLOOR</B></PRE>
<DL>
<DD>Key returned by <code>getCommonFunctionKey ()</code> for the floor value function.</DL>
<HR>

<A NAME="FUNCTION_CEIL"><!-- --></A><H3>
FUNCTION_CEIL</H3>
<PRE>
public static final java.lang.Integer <B>FUNCTION_CEIL</B></PRE>
<DL>
<DD>Key returned by <code>getCommonFunctionKey ()</code> for the ceil value function.</DL>
<HR>

<A NAME="FUNCTION_ROUND"><!-- --></A><H3>
FUNCTION_ROUND</H3>
<PRE>
public static final java.lang.Integer <B>FUNCTION_ROUND</B></PRE>
<DL>
<DD>Key returned by <code>getCommonFunctionKey ()</code> for the round value function.</DL>
<HR>

<A NAME="FUNCTION_ABS"><!-- --></A><H3>
FUNCTION_ABS</H3>
<PRE>
public static final java.lang.Integer <B>FUNCTION_ABS</B></PRE>
<DL>
<DD>Key returned by <code>getCommonFunctionKey ()</code> for the absolute value function.</DL>
<HR>

<A NAME="FUNCTION_OPPOSITE"><!-- --></A><H3>
FUNCTION_OPPOSITE</H3>
<PRE>
public static final java.lang.Integer <B>FUNCTION_OPPOSITE</B></PRE>
<DL>
<DD>Key returned by <code>getCommonFunctionKey ()</code> for the opposite function.</DL>
<HR>

<A NAME="FUNCTION_NOT"><!-- --></A><H3>
FUNCTION_NOT</H3>
<PRE>
public static final java.lang.Integer <B>FUNCTION_NOT</B></PRE>
<DL>
<DD>Key returned by <code>getCommonFunctionKey ()</code> for the not function.</DL>
<HR>

<A NAME="USER_STARTING_KEY"><!-- --></A><H3>
USER_STARTING_KEY</H3>
<PRE>
public static final int <B>USER_STARTING_KEY</B></PRE>
<DL>
<DD>Key starting value for user keys.</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->


<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="getLiteral(java.lang.String, java.lang.StringBuffer)"><!-- --></A><H3>
getLiteral</H3>
<PRE>
public java.lang.Object <B>getLiteral</B>(java.lang.String&nbsp;expression,
                                   java.lang.StringBuffer&nbsp;extractedLiteral)</PRE>
<DL>
<DD>Returns the value of the literal parsed from the string <code>expression</code>
 or <code>null</code> if <code>expression</code> doesn't start with a literal. If a
 literal is found at the beginning of <code>expression</code>, this method extracts
 the parsed literal in the string buffer <code>extractedLiteral</code>.
 The extracted literal is any literal valid for the syntax, a number, a string or other kind
 of literal value. The <code>getLiteralValue ()</code> method of <code>Interpreter</code>
 must be implemented to return the value matching the value returned by this method that
 the interpreter accepts to use.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>expression</CODE> - the string to parse.<DD><CODE>extractedLiteral</CODE> - the literal extracted from <code>expression</code> identified
                          as a valid literal with the syntax of the parser. This string buffer
                          is emptied before the call of this method by the parser.<DT><B>Returns:</B><DD>the value of the extracted literal or <code>null</code> if <code>expression</code>
         doesn't start with a literal valid for the syntax. If the literal is a number,
         an instance of <code>Number</code> should be returned, if the literal is a string
         an instance of <code>String</code> should be returned. Otherwise the returned value
         may be of any class, as long as the methods of the used interpreter at runtime is able
         to use them.</DL>
</DD>
</DL>
<HR>

<A NAME="getConstantKey(java.lang.String)"><!-- --></A><H3>
getConstantKey</H3>
<PRE>
public java.lang.Object <B>getConstantKey</B>(java.lang.String&nbsp;constant)</PRE>
<DL>
<DD>Returns the key matching <code>constant</code> (one of <code>CONSTANT_PI</code>,
 <code>CONSTANT_E</code>, <code>CONSTANT_FALSE</code>, <code>CONSTANT_TRUE</code> or
 an other user defined key). The <code>getLiteralValue ()</code> method of <code>Interpreter</code>
 must be implemented to return a value for this key (for example <code>getLiteralValue ()</code>
 can return the object <code>new Double (Math.PI)</code> for a key equal to <code>CONSTANT_PI</code>).<br>
 This method is not used by <code>CalculatorParser</code> parser.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>constant</CODE> - the string to test. Numeric and string literals are not checked by this method.<DT><B>Returns:</B><DD>the key matching the constant string or <code>null</code> if <code>constant</code>
         isn't a constant of the syntax.<DT><B>See Also: </B><DD><A HREF="../../../com/eteks/parser/Interpreter.html"><CODE>Interpreter</CODE></A>, 
<A HREF="../../../com/eteks/parser/AbstractSyntax.html#setConstantKey(java.lang.String, java.lang.Object)"><CODE>AbstractSyntax.setConstantKey(java.lang.String, java.lang.Object)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getUnaryOperatorKey(java.lang.String)"><!-- --></A><H3>
getUnaryOperatorKey</H3>
<PRE>
public java.lang.Object <B>getUnaryOperatorKey</B>(java.lang.String&nbsp;unaryOperator)</PRE>
<DL>
<DD>Returns the key matching <code>unaryOperator</code> (one of <code>OPERATOR_POSITIVE</code>,
 <code>OPERATOR_OPPOSITE</code>, <code>OPERATOR_LOGICAL_NOT</code>, <code>OPERATOR_BITWISE_NOT</code> or
 an other user defined key). The <code>getUnaryOperatorValue ()</code> method of <code>Interpreter</code>
 must be implemented to compute the operator of this key (for example <code>getUnaryOperatorValue ()</code>
 can compute the opposite operation of its parameter for a key equal to <code>OPERATOR_OPPOSITE</code>).<br>
 <code>getUnaryOperatorKey ()</code> and <code>getBinaryOperatorKey ()</code> may support
 some synonymous operators (as the operators - or +). The parser manages to guess
 whether a synonymous operator is an unary or a binary operator according to the context.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>unaryOperator</CODE> - the string to test.<DT><B>Returns:</B><DD>the key matching the unary operator or <code>null</code> if <code>unaryOperator</code>
         isn't a unary operator the syntax.<DT><B>See Also: </B><DD><A HREF="../../../com/eteks/parser/Interpreter.html"><CODE>Interpreter</CODE></A>, 
<A HREF="../../../com/eteks/parser/AbstractSyntax.html#setUnaryOperatorKey(java.lang.String, java.lang.Object)"><CODE>AbstractSyntax.setUnaryOperatorKey(java.lang.String, java.lang.Object)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getBinaryOperatorKey(java.lang.String)"><!-- --></A><H3>
getBinaryOperatorKey</H3>
<PRE>
public java.lang.Object <B>getBinaryOperatorKey</B>(java.lang.String&nbsp;binaryOperator)</PRE>
<DL>
<DD>Returns the key matching <code>binaryOperator</code> (one of <code>OPERATOR_ADD</code>,
 <code>OPERATOR_SUBSTRACT</code>, <code>OPERATOR_MULTIPLY</code>, <code>OPERATOR_DIVIDE</code>,... or
 an other user defined key). The <code>getBinaryOperatorValue ()</code> method of <code>Interpreter</code>
 must be implemented to compute the operator of this key (for example <code>getBinaryOperatorValue ()</code>
 can compute the addition of its parameters for a key equal to <code>OPERATOR_ADD</code>).<br>
 <code>getUnaryOperatorKey ()</code> and <code>getBinaryOperatorKey ()</code> may support
 some synonymous operators (as the operators - or +). The parser manages to guess
 whether a synonymous operator is an unary or a binary operator according to the context.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>binaryOperator</CODE> - the string to test.<DT><B>Returns:</B><DD>the key matching the binary operator or <code>null</code> if <code>binaryOperator</code>
         isn't a binary operator of the syntax.<DT><B>See Also: </B><DD><A HREF="../../../com/eteks/parser/Interpreter.html"><CODE>Interpreter</CODE></A>, 
<A HREF="../../../com/eteks/parser/AbstractSyntax.html#setBinaryOperatorKey(java.lang.String, java.lang.Object)"><CODE>AbstractSyntax.setBinaryOperatorKey(java.lang.String, java.lang.Object)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getConditionPartKey(java.lang.String)"><!-- --></A><H3>
getConditionPartKey</H3>
<PRE>
public java.lang.Object <B>getConditionPartKey</B>(java.lang.String&nbsp;conditionPart)</PRE>
<DL>
<DD>Returns the key matching <code>conditionPart</code> (one of <code>CONDITION_IF</code>,
 <code>CONDITION_THEN</code>, <code>CONDITION_ELSE</code>). The <code>getConditionValue ()</code> method
 of <code>Interpreter</code> must be implemented to return the good value if a condition is true
 or false.<br>
 This method is not used by <code>CalculatorParser</code> parser.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>conditionPart</CODE> - the string to test.<DT><B>Returns:</B><DD>the key matching the conditional part or <code>null</code> if <code>conditionPart</code>
         isn't a conditional part of the syntax or if no condition is supported by the syntax.<DT><B>See Also: </B><DD><A HREF="../../../com/eteks/parser/Interpreter.html"><CODE>Interpreter</CODE></A>, 
<A HREF="../../../com/eteks/parser/AbstractSyntax.html#setConditionPartKey(java.lang.String, java.lang.Object)"><CODE>AbstractSyntax.setConditionPartKey(java.lang.String, java.lang.Object)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getConditionPartCount()"><!-- --></A><H3>
getConditionPartCount</H3>
<PRE>
public int <B>getConditionPartCount</B>()</PRE>
<DL>
<DD>Returns 2 or 3 depending on whether the syntax using a condition with two or three parts (then else
 parts or if then else parts. <br>
 This method is not used by <code>CalculatorParser</code> parser.<DD><DL>
<DT><B>Returns:</B><DD>2 or 3.</DL>
</DD>
</DL>
<HR>

<A NAME="getCommonFunctionKey(java.lang.String)"><!-- --></A><H3>
getCommonFunctionKey</H3>
<PRE>
public java.lang.Object <B>getCommonFunctionKey</B>(java.lang.String&nbsp;commonFunction)</PRE>
<DL>
<DD>Returns the key matching <code>commonFunction</code> (one of <code>FUNCTION_LN</code>,
 <code>FUNCTION_LOG</code>, <code>FUNCTION_EXP</code>, <code>FUNCTION_SQR</code>,... or
 an other user defined key). The <code>getCommonFunctionValue ()</code> method of <code>Interpreter</code>
 must be implemented to compute the function of this key (for example <code>getCommonFunctionValue ()</code>
 can compute the nepierian logarithm of its parameter for a key equal to <code>FUNCTION_LN</code>).
 Common functions have only one parameter and may be called with no brackets
 around their parameter if <code>isShortSyntax ()</code> returns <code>true</code>.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>commonFunction</CODE> - the string to test.<DT><B>Returns:</B><DD>the key matching the common function or <code>null</code> if <code>commonFunction</code>
         isn't a common function of the syntax.<DT><B>See Also: </B><DD><A HREF="../../../com/eteks/parser/Interpreter.html"><CODE>Interpreter</CODE></A>, 
<A HREF="../../../com/eteks/parser/AbstractSyntax.html#setCommonFunctionKey(java.lang.String, java.lang.Object)"><CODE>AbstractSyntax.setCommonFunctionKey(java.lang.String, java.lang.Object)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getFunction(java.lang.String)"><!-- --></A><H3>
getFunction</H3>
<PRE>
public <A HREF="../../../com/eteks/parser/Function.html">Function</A> <B>getFunction</B>(java.lang.String&nbsp;functionName)</PRE>
<DL>
<DD>Returns a reference to the instance of <code>Function</code> whose name is <code>functionName</code>.
 This enables to call in an other function a previously parsed function or a function
 implementing the <code>Function</code> interface.
 The <code>getFunctionValue ()</code> method of <code>Interpreter</code>
 must be implemented to compute the returned function.<br>
 This method is not used by <code>CalculatorParser</code> parser.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>functionName</CODE> - the string to test.<DT><B>Returns:</B><DD>a <code>Function</code> reference or <code>null</code> if <code>functionName</code>
         isn't a function of the syntax.<DT><B>See Also: </B><DD><A HREF="../../../com/eteks/parser/Function.html"><CODE>Function</CODE></A>, 
<A HREF="../../../com/eteks/parser/Interpreter.html"><CODE>Interpreter</CODE></A>, 
<A HREF="../../../com/eteks/parser/AbstractSyntax.html#addFunction(com.eteks.parser.Function)"><CODE>AbstractSyntax.addFunction(com.eteks.parser.Function)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getBinaryOperatorPriority(java.lang.Object)"><!-- --></A><H3>
getBinaryOperatorPriority</H3>
<PRE>
public int <B>getBinaryOperatorPriority</B>(java.lang.Object&nbsp;binaryOperatorKey)</PRE>
<DL>
<DD>Returns the priority of the binary operator matching the key <code>binaryOperatorKey</code>. Two
 operators may have the same priority. A greater value is returned for an operator with higher priority.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>binaryOperatorKey</CODE> - a binary operator key (one of <code>OPERATOR_ADD</code>,
            <code>OPERATOR_SUBSTRACT</code>, <code>OPERATOR_MULTIPLY</code>,
            <code>OPERATOR_DIVIDE</code>,... or an other user defined key).<DT><B>Returns:</B><DD>a positive value equal to the priority of <code>binaryOperatorKey</code>.<DT><B>See Also: </B><DD><A HREF="../../../com/eteks/parser/AbstractSyntax.html#setBinaryOperatorPriority(java.lang.Object, int)"><CODE>AbstractSyntax.setBinaryOperatorPriority(java.lang.Object, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getWhiteSpaceCharacters()"><!-- --></A><H3>
getWhiteSpaceCharacters</H3>
<PRE>
public java.lang.String <B>getWhiteSpaceCharacters</B>()</PRE>
<DL>
<DD>Returns a string that contains all the delimiters allowed by the syntax as white spaces
 (tab, spaces,...).<DD><DL>
<DT><B>Returns:</B><DD>A string containing a set of white spaces or <code>null</code>.<DT><B>See Also: </B><DD><A HREF="../../../com/eteks/parser/AbstractSyntax.html#setWhiteSpaceCharacters(java.lang.String)"><CODE>AbstractSyntax.setWhiteSpaceCharacters(java.lang.String)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getOpeningBracket()"><!-- --></A><H3>
getOpeningBracket</H3>
<PRE>
public char <B>getOpeningBracket</B>()</PRE>
<DL>
<DD>Returns the char used as the opening bracket of the syntax. Brackets are use to
 brackets expressions and to pass parameters to a function.<DD><DL>
<DT><B>Returns:</B><DD>the opening bracket char or 0 if no brackets are used.<DT><B>See Also: </B><DD><A HREF="../../../com/eteks/parser/AbstractSyntax.html#setOpeningBracket(char)"><CODE>AbstractSyntax.setOpeningBracket(char)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getClosingBracket()"><!-- --></A><H3>
getClosingBracket</H3>
<PRE>
public char <B>getClosingBracket</B>()</PRE>
<DL>
<DD>Returns the char used as the closing bracket of the syntax. Brackets are use to
 brackets expressions and to pass parameters to a function.<DD><DL>
<DT><B>Returns:</B><DD>the closing bracket char or 0 if no brackets are used.<DT><B>See Also: </B><DD><A HREF="../../../com/eteks/parser/AbstractSyntax.html#setClosingBracket(char)"><CODE>AbstractSyntax.setClosingBracket(char)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getParameterSeparator()"><!-- --></A><H3>
getParameterSeparator</H3>
<PRE>
public char <B>getParameterSeparator</B>()</PRE>
<DL>
<DD>Returns the char used to separate parameters in a function call. <br>
 This method is not used by <code>CalculatorParser</code> parser.<DD><DL>
<DT><B>Returns:</B><DD>the separator of parameters or 0 if no multi parameters function calls
         are allowed by the syntax.<DT><B>See Also: </B><DD><A HREF="../../../com/eteks/parser/AbstractSyntax.html#setParameterSeparator(char)"><CODE>AbstractSyntax.setParameterSeparator(char)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getDelimiters()"><!-- --></A><H3>
getDelimiters</H3>
<PRE>
public java.lang.String <B>getDelimiters</B>()</PRE>
<DL>
<DD>Returns all the chars of the syntax that may be used as delimiters
 between literals, constants and other identifiers. This string must contain at least the
 delimiters returned by <code>getWhiteSpaceCharacters ()</code> and
 generally contains the opening and closing brackets, the separator of parameters and the
 characters of operators, that are not part of literals, constants and identifiers.
 The <code>AbstractSyntax</code> class computes automatically this string.<DD><DL>
<DT><B>Returns:</B><DD>a string containing the set of delimiters of the syntax.<DT><B>See Also: </B><DD><A HREF="../../../com/eteks/parser/AbstractSyntax.html#getDelimiters()"><CODE>AbstractSyntax.getDelimiters()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getAssignmentOperator()"><!-- --></A><H3>
getAssignmentOperator</H3>
<PRE>
public java.lang.String <B>getAssignmentOperator</B>()</PRE>
<DL>
<DD>Returns the string used as the operator of assignment by
 the parsers <code>FunctionParser</code> and <code>ExpressionParser</code>.
 <UL><LI>For parsing of functions, it's the string that separates the declaration of the function
     from its list of parameters, before the expression of the function like the char <code>=</code> in the string
     <code>f(x) = x + 1</code> ; <code>FunctionParser</code> requires a valid
     assignment operator to parse a function.</LI>
     <LI>For expressions parsed with an instance of <code>ExpressionParser</code>, it's the string
     at the beginning of the expression like the char <code>=</code> in the string
     <code>= A1 + 1</code>, if  this string isn't <code>null</code>.</LI></UL>
 This method is not used by <code>CalculatorParser</code> parser.<DD><DL>
<DT><B>Returns:</B><DD>the operator of assignment.<DT><B>See Also: </B><DD><A HREF="../../../com/eteks/parser/FunctionParser.html"><CODE>FunctionParser</CODE></A>, 
<A HREF="../../../com/eteks/parser/AbstractSyntax.html#setAssignmentOperator(java.lang.String)"><CODE>AbstractSyntax.setAssignmentOperator(java.lang.String)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isCaseSensitive()"><!-- --></A><H3>
isCaseSensitive</H3>
<PRE>
public boolean <B>isCaseSensitive</B>()</PRE>
<DL>
<DD>Returns <code>true</code> if identifiers, constants, operators and function of the syntax
 are case sensitive. Note that this method is used by the parser only for tests comparing
 the name of functions and parameters. <code>getConstantKey ()</code>,
 <code>getUnaryOperatorKey ()</code>, <code>getBinaryOperatorKey ()</code>,
 <code>getConditionPartKey ()</code> and <code>getCommonFunctionKey ()</code> methods must perform
 the good test of comparison depending on whether the syntax being case sensitive or not.<br>
 This method is not used by <code>CalculatorParser</code> parser.<DD><DL>
<DT><B>Returns:</B><DD><code>true</code> if the syntax is case sensitive.<DT><B>See Also: </B><DD><A HREF="../../../com/eteks/parser/AbstractSyntax.html#AbstractSyntax()"><CODE>AbstractSyntax.AbstractSyntax()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isShortSyntax()"><!-- --></A><H3>
isShortSyntax</H3>
<PRE>
public boolean <B>isShortSyntax</B>()</PRE>
<DL>
<DD>Returns <code>true</code> if expressions parsed with this syntax supports short cuts.
 <UL><LI>If this method returns <code>false</code>, the syntax is the one generally used in
         data processing, i.e. every multiply operator is written and
         the parameters of common functions are always between brackets
         (for example <code>f(x) = 2*sin(x) + 3*x</code>).</LI>
     <LI>If this method returns <code>true</code>, the syntax supports also the mathematical
         syntax, i.e. multiply operator and brackets around the parameters of common
         functions may be omitted. If a literal number is directly followed by an
         identifier, a function or an expression between brackets without
         any white space character, an implicit multiplication will be performed (for example :
         <code>f(x) = 2x</code> or <code>f(x) = 5.2E-2(ln x + 3)</code>).
         More generally, a multiplication is applied to two operands if they are separated
         by one or more white space characters (for example : <code>f(x,y) = x y ou f(x) = x ln x</code>).<br>
         As a common function has a higher priority than any binary operator,
         its parameter must be bracketed if it's the result of an operation as in this example :
         <code>f(x) = log(2x)</code> is different of <code>f(x) = log 2x</code>.<br>
         As the unary operators and calls to common functions have the highest priority and
         are right-to-left associative, it allows to write a function like this one :
         <code>f(x) = sqr log -x</code> which is the same as <code>f(x) = sqr (log (-x))</code>.
         Note than these short cuts are allowed only for common functions, not
         for user functions even if they require only one parameter.<br>
         Implicit multiplication isn't supported by the <code>CalculatorParser</code> class.</LI></UL><DD><DL>
<DT><B>Returns:</B><DD><code>true</code> if the syntax supports short cuts.<DT><B>See Also: </B><DD><A HREF="../../../com/eteks/parser/AbstractSyntax.html#setShortSyntax(boolean)"><CODE>AbstractSyntax.setShortSyntax(boolean)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isValidIdentifier(java.lang.String)"><!-- --></A><H3>
isValidIdentifier</H3>
<PRE>
public boolean <B>isValidIdentifier</B>(java.lang.String&nbsp;identifier)</PRE>
<DL>
<DD>Returns <code>true</code> if the string <code>identifier</code> is a correctly written identifier
 to be used as a user function name, a user function paramater name or an expression parameter.
 <code>identifier</code> may contain special characters as : or . if these
 characters are not used as delimiters.<br>
 This method is not used by <code>CalculatorParser</code> parser.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>identifier</CODE> - the string to test.<DT><B>Returns:</B><DD><code>true</code> if <code>identifier</code> is correct.</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_bottom"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<P><CENTER>&cp; 1998-2003 eTeks - All rights reserved</CENTER></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../com/eteks/parser/Interpreter.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;NEXT CLASS</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Syntax.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY: &nbsp;INNER&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL: &nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>

</BODY>
</HTML>
